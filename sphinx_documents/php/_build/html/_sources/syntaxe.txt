##########
La syntaxe
##########

.. contents:: :depth: 2
   
***********
Généralités
***********

Les balises PHP
================

Tout code PHP doit être inclus dans une balise ``<?php ... ?>``.
Les balises courtes ``<? ... ?>`` et ``<?= ... ?>`` sont acceptées si la configuration les autorisent,
mais ne sont pas recommandées.

Les instructions sont séparées par le point-virgule ``;``.

Les commentaires
================

Il existe trois manières d'inclure un commentaire dans du code PHP :

* entre les signes ``/*`` et ``*/``
* en commencant une ligne par ``//``
* en commencant une ligne par ``#``

Les signes ``/*`` et ``*/`` sont les seules qui permettent de faire un commentaire sur plusieurs lignes.
Pour les deux autres symboles, il faudra le remettre au début de chaque ligne de commentaire.

On peut mixer les types de commentaire dans un même script.

Les variables
=============

Un nom de variable commencent toujours par un dollar ``$``,
suivit d'au moins un caractère non numérique (``_`` est autorisé) puis de n'importe quel caractère.
  
Les noms de variables sont sensibles à la case, donc $maVariable est différentnde $ma_variable.
Il est donc vivement recommendé de fixer une norme pour le nommage des variables.

Les varaibles ne sont pas typées. Au cours de l'exécution du script, le type de la valeur affectée à une varible peut changer.
L'interpréteur se charge de gérer les allocations de mémoire nécessaires au stockage des valeurs référencées par les variables.

Il n'y a pas de déclaration de variable en PHP.
L'interpréteur crée automatiquement une variable dès qu'un nouveau symbole préfixé par ``$`` apparaît dans un script.

Les constantes
==============

Une constante est un symbole associé à une valeur mais, contrairement aux variables, sa valeur ne change jamais.
Elles sont définies par la commande ``define()``.

.. code-block:: php

    define("PI", 3.14116);
    define("FOO", "something");
	
    // Noms invalides
    define("2FOO", "something");
    
    // Ce nom est valide, mais évitez-le:
    // PHP peut un jour fournir une constante magique nommée
    // ainsi, ce qui va corrompre vos scripts.
    define("__FOO__", "something");
	
Par convention, les nom des constantes sont en majuscule.

*********
Les types
*********

Les booléens
============

Il peut valoir ``TRUE`` ou ``FALSE``.
 
Lors d'une conversion en booléen, les valeurs suivantes sont considérées comme ``FALSE`` :
 
* le booléen ``FALSE``, lui-même
* l'entier ``0``
* le nombre à virgule flottante ``0.0``
* la chaîne vide, et la chaîne ``"0"``
* un tableau avec aucun élément
* le type spécial ``NULL`` (incluant les variables non définies)

Les numériques
==============

Il comprènnent les entiers et les flottants.

Les entiers peuvent être spécifiés en notation décimale (base 10), hexadécimaled(base 16), octaled(base 8), ou binaire 
(base 2) optionnellement précédée d'undsigne (- ou +).

Les entiers littéraux binaires sont disponibles depuis PHP 5.4.0.

Pour utiliser la notation octale, précédez le nombre d'un 0 (zéro).
Pour utiliser la notation hexadécimale, précédez le nombre d'un 0x.
Pour utiliser l'anotation binaire, précédez le nombre d'un 0b.

.. code-block:: php

	$a = 1234; // un nombre décimal
	$a = -123; // un nombre négatif
	$a = 0123; // un nombre octal (équivalent à 83 en décimal)
	$a = 0x1A; // un nombre héxadecimal (équivalent à 26 en décimal)
	$a = 0b11111111; // un nombre binaire (équivalent à 255 en decimal)
	
Les flottants peuvent être spécifiés en utilisant les syntaxes suivantes :

.. code-block:: php

    $a = 1.234;
    $b = 1.2e3;
    $c = 7E-10;

Les chaînes de caractères
=========================

Une chaîne de caractères littérale peut être spécifiée de 4 façons différentes :

* Entourée de guillemets simples
  
  .. code-block:: php
  
    echo 'Arnold a dit : "I\'ll be back"'              // Affiche : Arnold a dit : "I'll be back"
    echo 'Ceci n\'affichera pas \n de nouvelle ligne'  // Affiche : Ceci n'affichera pas \n de nouvelle ligne
    echo 'Les variables ne seront pas $traitees $ici'  // Affiche : Les variables ne seront pas $traitees $ici
    
* Entourée de guillemets doubles
  
  .. code-block:: php
  
    $juice = "pomme";
    echo "Il a bu du jus de $juice.".PHP_EOL;     // Affiche : Il a bu du jus de pomme."
    echo "Il a bu du jus constitué de $juices."   // Affiche : Il a bu du jus constitué de .

* Syntaxe Heredoc
  
  .. code-block:: php
  
    $str = <<<EOD
    Exemple de chaîne
    sur plusieurs lignes
    en utilisant la syntaxe Heredoc.
    EOD;

    $name = 'MyName';
    $foo = 'Foo';
    $foobar = 'Bar2';
    echo <<<EOT
    Mon nom est "$name". J'affiche quelques ${foo}.
    Maintenant, j'affiche quelques {$foobar}.
    Et ceci devrait afficher un 'A' majuscule : \x41
    EOT;
    
    // Affiche
    // Mon nom est "MyName". J'affiche quelques Foo.
    // Maintenant, j'affiche quelques Bar2.
    // Et ceci devrait afficher un 'A' majuscule : A

    <<<FOOBAR
    My text
    FOOBAR;

    // Depuis PHP 5.3.0, l'identifiant de début de syntaxe Heredoc peut éventuellement être écrit entre guillemets doubles :
    echo <<<"FOOBAR"
    Hello World!
    FOOBAR;
    
* Syntaxe Nowdoc (depuis PHP 5.3.0) 
  
  .. code-block:: php
  
    $str = <<<'EOD'
    Exemple de chaîne
    sur plusieurs lignes
    en utilisant la syntaxe Nowdoc.
    EOD;
  
    echo <<<'EOT'
    Mom nom est "$name". J'affiche quelques $foo->foo.
    Maintenant, j'affiche quelques {$foo->bar[1]}.
    Ceci ne devrait pas afficher un 'A' : \x41
    EOT;
  
    // Affiche
    // Mom nom est "$name". J'affiche quelques $foo->foo.
    // Maintenant, j'affiche quelques {$foo->bar[1]}.
    // Ceci ne devrait pas afficher un 'A' : \x41

Les tableaux
============

Un tableau est un ensemble qui associe une clé à une valeur.
Une clé est un entier ou une chaîne de caractères.
La valeur peut être de n'importe quel type. 

.. code-block:: php
  
    $array = array(
        key  => value,
        key2 => value2,
        key3 => value3,
        ...
    )
    
Depuis PHP 5.4.0, il existe une syntaxe courte pour déclarer un tableau :

.. code-block:: php

   $array = [
        key  => value,
        key2 => value2,
        key3 => value3,
        ...
    ]
    
Les objets
==========

Pour intancier un nouvel objet, il faut utiliser le mot clé ``new`` :

.. code-block:: php
    
    $date = new DateTime('2015-01-01');
    
On utilise le synbole ``->`` pour accéder au méthodes et attributs de l'objet :

.. code-block:: php
    
    $date->format('d/m/Y');

**************
Les opérateurs
**************

Les opérateurs arithmétiques
============================

* Négation ``-`` : ``-$a``
* Addition ``+`` : ``$a + $b``
* Soustraction ``-`` : ``$a - $b``
* Multiplication ``*`` : ``$a * $b``
* Division ``/`` : ``$a / $b``
* Modulo ``%`` : ``$a % $b``
* Exponentielle ``**`` : ``$a ** $b``

Les opérateurs d'affectation
============================

L'opérateur d'affectation le plus simple est le signe "=".

En plus du simple opérateur d'affectation, il existe des "opérateurs combinés" pour tous les opérateurs arithmétiques,
l'union de tableaux et pour les opérateurs sur les chaînes de caractères :

.. code-block:: php

    $a = 3;
    $a += 5; // affecte la valeur 8 à la variable $a correspond à l'instruction '$a = $a + 5';

    $b = "Bonjour ";
    $b .= " tout le monde!";  // affecte la valeur "Bonjour tout le monde!" 
                              // à la variable $b
                              // identique à $b = $b . " tout le monde!";
                              
    $c = array("a" => "pomme", "b" => "banane");
    $d = array("a" =>"poire", "b" => "fraise", "c" => "cerise");
    $c += $d;  // affecte la valeur array("a" =>"pomme", "b" => "banane", "c" => "cerise")
               // à la variable $c
               // correspond à l'instruction '$c = $c + $d';

Les opérateurs sur les bits
===========================

* And (Et) ``&`` : ``$a & $b``
* Or (Ou) ``|`` : ``$a | $b``
* Xor (ou exclusif) ``^`` : ``$a ^ $b``
* Not (Non) ``~`` : ``$a ~ $b``
* Décalage à gauche ``<<`` : ``$a << $b``
* Décalage à droite ``>>`` : ``$a >> $b``

Opérateurs de comparaison
=========================

* Egal ``==`` : ``$a == $b`` (égals après transtypage)
* Identique ``===`` : ``$a === $b`` (égals et de même type)
* Différent ``!=`` : ``$a != $b`` (différents après transtypage)
* Différent ``<>`` : ``$a <> $b`` (différents après transtypage)
* Différent ``!==`` : ``$a !== $b`` (différents et de même type)
* Plus petit que ``<`` : ``$a < $b``
* Plus grand ``>`` : ``$a > $b``
* Inférieur ou égal ``<=`` : ``$a <= $b``
* Supérieur ou égal ``>=`` : ``$a >= $b``

Opérateur de contrôle d'erreur
==============================

PHP supporte un opérateur de contrôle d'erreur : c'est ``@``. 
Lorsque cet opérateur est ajouté en préfixe d'une expression PHP, les messages d'erreur qui peuvent être générés par cette expression seront ignorés. 

Opérateur d'exécution
=====================

PHP supporte un opérateur d'exécution : guillemets obliques ("``"). Notez bien qu'il ne s'agit pas de guillemets simples.
PHP essaie d'exécuter le contenu de ces guillemets obliques comme une commande shell.
Le résultat sera retourné (i.e. : il ne sera pas simplement envoyé à la sortie standard, il peut être affecté à une variable).
Utilisez les guillemets obliques revient à utiliser la fonction shell_exec().

Opérateurs d'incrémentation et décrémentation
=============================================

* Pre-incrémente ``++`` : ``++$a``
* Post-incrémente ``++`` : ``$a++``
* Pré-décrémente ``--`` : ``--$a``
* Post-décrémente ``--`` : ``$a++``

.. code-block:: php

    $a = 5;
    echo $a++; // Affiche 5
    echo $a; // Affiche 6
    
    $a = 5;
    echo ++$a; // Affiche 6
    echo $a; // Affiche 6

    $a = 5;
    echo $a--; // Affiche 5
    echo $a; // Affiche 4
    
    $a = 5;
    echo --$a; // Affiche 4
    echo $a; // Affiche 4

Les opérateurs logiques
=======================

* And (Et) ``&&`` : ``$a && $b``
* Or (Ou) ``||`` : ``$a || $b``
* XOR ``xor`` : ``$a xor $b``
* Not (Non) ``!`` : ``!$a``
* And (Et) ``and`` : ``$a and $b``
* Or (Ou) ``or`` : ``$a or $b``

La raison pour laquelle il existe deux types de "ET" et de "OU" est qu'ils ont des priorités différentes.
Voir le paragraphe  `précédence d'opérateurs <http://fr2.php.net/manual/fr/language.operators.precedence.php>`_ de la doc de PHP. 

